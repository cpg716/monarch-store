# ğŸ“˜ MonARCH Store - Technical Documentation

## Architecture Overview

MonARCH Store uses the **Tauri v2** framework, combining a web-based frontend with a high-performance Rust backend.

### ğŸ–¥ï¸ Frontend (UI)
*   **Framework**: React (Vite) + TypeScript.
*   **Styling**: TailwindCSS (v4) with custom `App.css` for glassmorphism effects.
*   **State Management**: Zustand (local store) + React Hooks.
*   **Charts/Icons**: Lucide-React.

src/
â”œâ”€â”€ components/   # Reusable UI widgets (PackageCard, SearchBar, etc.)
â”œâ”€â”€ pages/        # Main Views (PackageDetails, Installed, etc.)
â”œâ”€â”€ services/     # API Layers (reviewService.ts - Supabase/ODRS)
â””â”€â”€ hooks/        # Logic extraction (useFavorites, useInfiniteScroll)
```

### ğŸ¦€ Backend (Rust)
*   **Core**: `src-tauri/src/lib.rs` - Main entry point and command registration.
*   **Modules**:
    *   `aur_api.rs`: Async client for `aur.archlinux.org` RPC.
    *   `chaotic_api.rs`: Fetches and caches the massive `chaotic-aur` package list.
    *   `repo_manager.rs`: Handles `pacman` database syncing and local repo management.
    *   `review.rs` / `odrs_api.rs`: Interfaces for fetching ODRS ratings.

## ğŸ§  Key Features & Logic

### 1. Smart Package Resolution
When you search for "firefox", MonARCH doesn't just show one result. It aggregates from multiple sources and prioritizes them:
1.  **Chaotic-AUR** (Priority #1): Pre-built binary. Fastest install.
2.  **Official Repos** (Priority #2): Standard Arch package.
3.  **AppStream** (Priority #3): Metadata-rich results (icons/screenshots).
4.  **AUR** (Priority #4): Source build (fallback).

### 2. Hybrid Review System
We use a composite rating strategy to ensure every app has data:
*   **Step 1:** Check **ODRS** (Open Desktop Rating Service) using the AppStream ID (e.g., `org.mozilla.firefox`).
*   **Step 2:** If ODRS fails, check ODRS again using the package name.
*   **Step 3:** If still no data (common for AUR apps), query our **Supabase** `reviews` table.
*   **Display:** The UI merges this into a single 5-star rating component.

### 3. Analytics (Aptabase)
We track minimal, privacy-centric events:
*   `app_launch`: Version & OS tracking.
*   `install_clicked`: Which source (AUR vs Official) is preferred.
*   `search`: Query keywords (to identify missing packages).

## ğŸ› ï¸ Build & Release

To cut a new release:
1.  Update `version` in `package.json` and `src-tauri/tauri.conf.json`.
2.  Update `src-tauri/Cargo.toml`.
3.  Run `npm run tauri build`.
4.  Tag commit with `vX.Y.Z`.

## â˜ï¸ Backend Configuration (Self-Hosting Community Reviews)

To enable **Community Reviews** with your own backend, you need to connect a Supabase instance.
*By default, the app comes pre-configured with read-only keys, or keys provided by the maintainer.*

1.  Create a **Supabase** project.
2.  Run the following SQL in your Supabase SQL Editor:
    ```sql
    create table reviews (
      id bigint generated by default as identity primary key,
      package_name text not null,
      user_name text not null default 'Anonymous',
      rating int not null check (rating >= 1 and rating <= 5),
      comment text,
      created_at timestamp with time zone default timezone('utc'::text, now()) not null
    );
    alter table reviews enable row level security;
    create policy "Public Read" on reviews for select using (true);
    create policy "Public Insert" on reviews for insert with check (true);
    ```
3.  Update `src/services/reviewService.ts` with your **Project URL** and **Anon Key**.
